#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
const int doodlebugNumber = 5 ;
const int grid = 20 ;
const int gridSize = 400 ;
const int antNumber = 100 ;
const int doodleNumber = 5 ;
using namespace std ;
char locationList[gridSize]; 
char adjacent[4] ;

class Organism
{
    int ID ;
    int location;
    int count ;
    char status ;
    char species ;
public:
    Organism() : ID(1), location(1), count(0), status('s') {}
    int getID() const { return ID; }
    int getLocation() const { return location; }
    void setLocation( int newLocation ){ location = newLocation; } ;
    int getCount() const { return count; }
    void setCount( int newCount ){ count = newCount ;} ;
    char getStatus() const { return status; }
    void setStatus(char newStatus) { status = newStatus; }
    char getSpecies() const { return species; }
    void setSpecies(char newSpecies) { species = newSpecies; }
    void adjecentCell( int aLocation ) ;
    int newSpace(int aLocation, int space, char ocupant ) ;
    virtual void move() = 0 ;
};
void Organism :: adjecentCell( int aLocation )
{
    if ( aLocation < grid ){
        adjacent[0] = 'n' ; // upper cell doesn't exist
    }
    else {
        adjacent[0] = locationList[ aLocation - grid ]  ;
    }
    if ( aLocation > gridSize - grid - 1 ){
        adjacent[1] = 'n' ; // lower cell doesn't exist
    }
    else {
        adjacent[1] = locationList[ aLocation + grid ]  ;
    }
    if ( aLocation % 20 == 0 ){
        adjacent[2] = 'n' ; // left cell doesn't exist
    }
    else {
        adjacent[2] = locationList[ aLocation - 1 ]  ;
    }
    if ( aLocation % 20 == 19 ){
        adjacent[3] = 'n' ; // right cell doesn't exist
    }
    else {
        adjacent[3] = locationList[ aLocation + 1 ]  ;
    }
}
int Organism :: newSpace(int aLocation, int space, char ocupant )
{
    int n = 0 ;
    int newSpace ;
    int random= rand() % (space + 1);
    for ( int i = 0 ; i < random ; i ++ ){
        if ( adjacent[n] == ocupant ){
            n ++ ;
        }
        else {
            i -= 1 ;
        }
    }
    switch (n){
        case 1:
            newSpace =  aLocation - grid ;
            break ;
        case 2:
            newSpace =  aLocation + grid ;
            break ;
        case 3:
            newSpace =  aLocation - 1 ;
            break ;
        case 4:
            newSpace =  aLocation + 1 ;
            break ;
    }
    return newSpace ;
}

class Doodlebug : public Organism
{
    int survive ;
public:
    Doodlebug( int id, int location, int count, char status, char breed, int survive ) : Organism(), survive(survive) {}
    void move() ;
    void setLocation( int newLocation ) { Organism::setLocation(newLocation); }
    int getSurvive() const { return survive; }
    void setSurvive ( int newSurvive ) { survive = newSurvive; }
    Doodlebug& operator = (const Organism & org) ;
};
vector <Doodlebug*> db ;

void Doodlebug :: move()
{
    int newDoodleNumber, newLocation, aLocation;
    int space = 0 ;
    if ( getStatus() != 'd'){
        if ( getCount() == 3 ){
            setStatus('d') ;
        }
        else {
            aLocation = getLocation() ;
            adjecentCell(aLocation) ;
            // if the bug can breed
            if ( getSurvive() == 8 ){
                newDoodleNumber = db.size() + 1;
                for ( int n = 0 ; n < 4 ; n ++){
                    if ( adjacent[n] == '-' ){
                        space ++ ;
                    }
                }
                if ( space != 0 ){
                    int newLocation = newSpace ( aLocation, space, '-' ) ;
                    db.push_back( new Doodlebug( newDoodleNumber, newLocation, 0, 'm', 'X', 0) );
                    locationList[newLocation] = 'X' ;
                }
                setSurvive(0) ;
            }
            // if there is ant nearby
            adjecentCell(aLocation) ;
            space = 0 ;
            for ( int n = 0 ; n < 4 ; n ++){
                if ( adjacent[n] == 'o' ){
                    space ++ ;
                }
            }
            if ( space != 0 ){
                newLocation = newSpace ( aLocation, space, 'o' ) ;
                locationList[newLocation] = 'X' ;
                locationList[aLocation] = '-' ;
                setCount(0) ;
            }
            // no ant
            else{
                space = 0 ;
                for ( int n = 0 ; n < 4 ; n ++){
                    if ( adjacent[n] == '-' ){
                        space ++ ;
                    }
                }
                if ( space != 0 ){
                    newLocation = newSpace ( aLocation, space, 'o' ) ;
                    locationList[newLocation] = 'X' ;
                    locationList[aLocation] = '-' ;
                    int newCount = getCount() + 1 ;
                    setCount(newCount) ;
                }
            }
            int newSurvive = getSurvive() + 1 ;
            setSurvive(newSurvive) ;
        }
    }
}

class Ant : public Organism
{
public:
    Ant(int id, int location, int count, char status, char breed ) : Organism() {}
    void move() ;
    void setLocation( int newLocation ) { Organism::setLocation(newLocation); }
    void setStatus( char newStatus ) ;
    Ant& operator = (const Organism & org) ;   
};

vector <Ant*> at ;

void Ant ::move()
{
    int newAntNumber, space, aLocation, newLocation ;
    if ( getStatus() != 'd'){
        aLocation = getLocation() ;
        if ( locationList[aLocation] == 'X' ){
            setStatus('d') ;
        }
        else {
            adjecentCell(aLocation) ;
            // if the ant can breed
            if ( getCount() == 3 ){
                newAntNumber = at.size() + 1;
                int space = 0 ;
                for ( int n = 0 ; n < 4 ; n ++){
                    if ( adjacent[n] == '-' ){
                        space ++ ;
                    }
                }
                if ( space != 0 ){
                    newLocation = newSpace ( aLocation, space, '-' ) ;
                    at.push_back( new Ant( newAntNumber, newLocation, 0, 'm', 'o') );
                    locationList[newLocation] = 'o' ;
                }
                setCount(0) ;
            }
            // if there is still empty space
            adjecentCell(aLocation) ;
            space = 0 ;
            for ( int n = 0 ; n < 4 ; n ++){
                if ( adjacent[n] == '-' ){
                    space ++ ;
                }
            }
            if ( space != 0 ){
                newLocation = newSpace ( aLocation, space, '-' ) ;
                locationList[newLocation] = 'o' ;
                locationList[aLocation] = '-' ;
            }
            int newCount = getCount() + 1 ;
            setCount(newCount) ;
        }
    }
}


int randLocation( int randnum ) ;
void initializeWorld() ;
void printWorld() ;

int main() {
    char input;
    int i ;
    for ( int i = 0 ; i < gridSize ; i ++){
        locationList[i] = '-' ;
    }
    initializeWorld() ;
    printWorld() ;
    cout << "Press enter to contiune" << endl ;
    while (true) {
        cin.get();
        for ( i = 0 ; i < db.size() ; i ++){
            db[i]->move() ;
        }
        for ( i = 0 ; i < at.size() ; i ++){
            at[i]->move() ;
        }
        printWorld();
        cout << "\n Press enter to contiune" << endl ;     
    }
    return 0 ;
}

void initializeWorld(){
    /* generate random location for doodlebug */
    srand(time(NULL));
    bool findLocation = false ;
    for ( int i = 1 ; i < doodleNumber + 1 ; i++ ){
        while ( findLocation == false ){
            int bugLocation = rand() % gridSize + 1;
            if (locationList[bugLocation] == '-'){
                db.push_back( new Doodlebug(i, bugLocation, 0, 'm', 'X', 0) );
                findLocation = true;
                locationList[bugLocation] = 'X' ;
            }
        }
        findLocation = false ;
    }
    /* generate random location for ant */
    srand(time(NULL));
    findLocation = false ;
    for ( int i = 1 ; i < antNumber + 1 ; i++ ){
        while ( findLocation == false ){
            int antLocation = rand() % gridSize + 1;
            if (locationList[antLocation] == '-'){
                at.push_back( new Ant(i, antLocation, 0, 'm', 'o' ) );
                findLocation = true;
                locationList[antLocation] = 'o' ;
            }
        }
        findLocation = false ;
    }
}

void printWorld(){
    for (int i = 0 ; i < gridSize ; i ++ ){
        cout << locationList[i] << ' ';
        if ( i % 20 == 19 ){
            cout << "\n" ;
        }
    }
}
